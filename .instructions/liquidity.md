# Futarchy Proposal & Liquidity Pool Implementation Plan

## High-Level Objectives
- Create a futarchy proposal using existing factory on Gnosis Chain
- Extract conditional tokens generated by the proposal
- Create SushiSwap v2 pools for conditional tokens paired with WXDAI
- Create SushiSwap v2 pools for YES/NO token pairs
- Deploy SushiSwap v3 pools with concentrated liquidity for specific token pairs
- Ensure all pools are initialized with market-appropriate prices

## Tasks
- [x] 1. Configuration System Setup
- [x] 2. Contract Interface Integration
- [x] 3. Price Oracle Implementation
- [x] 4. Proposal Creation
- [x] 5. Conditional Token Extraction
- [x] 6. Liquidity Calculation Engine
- [ ] 7. v2 Pool Deployment
- [ ] 8. v3 Pool Parameter Calculation
- [ ] 9. v3 Pool Deployment
- [ ] 10. Validation and Reporting

## Detailed Implementation Steps

### 1. Configuration System Setup [done]
**Objective:** Build a robust configuration parser for proposal settings and secrets
- **Requirements:**
  - Parse JSON proposal configuration (question, tokens, liquidity settings)
  - Load environment variables (private keys, contract addresses, RPC URLs)
  - Validate configuration completeness and format
  - Support array of proposals for batch processing
- **Expected Output:** Fully populated configuration object ready for use
- **Dependencies:** None
- **Implementation:**
  - **Files:**
    - `script/FutarchyProposalLiquidity.s.sol` - Main script with configuration parsing logic
    - `script/config/proposal.json` - Example single proposal configuration
    - `script/config/batch_proposals.json` - Example batch proposal configuration
    - `script/config/.env.example` - Template for environment variables
    - `script/config/README.md` - Documentation for configuration files
    - `script/test_config_parser.sh` - Test script for configuration parser
  - **Data Structures:**
    - `ProposalConfig` - Struct for proposal parameters (name, question, tokens, etc.)
    - `LiquidityConfig` - Struct for liquidity parameters (token amounts)
    - `EnvConfig` - Struct for environment variables (contract addresses, keys)
  - **Functions:**
    - `loadProposalConfig()` - Parses single proposal JSON configuration
    - `loadBatchProposalConfigs()` - Parses array of proposal configurations
    - `loadEnvConfig()` - Loads environment variables
    - `validateProposalConfig()` - Validates proposal configuration
    - `validateEnvConfig()` - Validates environment configuration
  - **Commands:**
    - Single proposal: `forge script script/FutarchyProposalLiquidity.s.sol:FutarchyProposalLiquidity --sig "run(string)" "script/config/proposal.json" --rpc-url $RPC_URL --private-key $PRIVATE_KEY`
    - Batch proposals: `forge script script/FutarchyProposalLiquidity.s.sol:FutarchyProposalLiquidity --sig "runBatch(string)" "script/config/batch_proposals.json" --rpc-url $RPC_URL --private-key $PRIVATE_KEY`
    - Test config parser: `./script/test_config_parser.sh`

### 2. Contract Interface Integration [done]
**Objective:** Establish communication with all required smart contracts
- **Requirements:**
  - Define interfaces for FutarchyFactory, FutarchyProposal, and FutarchyRouter
  - Create interfaces for SushiSwap v2 (Factory, Router, Pair)
  - Create interfaces for SushiSwap v3 (Factory, PositionManager, Pool)
  - Implement connection logic with proper ABI handling
- **Expected Output:** Functional contract interface instances
- **Dependencies:** Configuration from step 1
- **Implementation:**
  - **Files:**
    - `src/interfaces/IFutarchyFactory.sol` - Interface for creating futarchy proposals
    - `src/interfaces/IFutarchyProposal.sol` - Interface for interacting with proposals
    - `src/interfaces/IFutarchyRouter.sol` - Interface for managing proposal operations
    - `src/interfaces/ISushiswapV2Factory.sol` - Interface for creating SushiSwap v2 pairs
    - `src/interfaces/ISushiswapV2Pair.sol` - Interface for interacting with v2 pools
    - `src/interfaces/ISushiswapV2Router.sol` - Interface for adding liquidity to v2 pools
    - `src/interfaces/ISushiswapV3Factory.sol` - Interface for creating v3 pools
    - `src/interfaces/ISushiswapV3Pool.sol` - Interface for interacting with v3 pools
    - `src/interfaces/ISushiswapV3PositionManager.sol` - Interface for managing v3 positions
  - **Key Functionalities:**
    - **Futarchy Interfaces:**
      - Proposal creation and management
      - Conditional token extraction
      - Outcome token mapping (YES/NO tokens)
    - **SushiSwap v2 Interfaces:**
      - Pair creation and initialization
      - Liquidity provision
      - Reserve querying
    - **SushiSwap v3 Interfaces:**
      - Concentrated liquidity pool creation
      - Position management
      - Price range configuration
  - **Implementation Details:**
    - All interfaces aligned with Solidity 0.8.20 compiler version
    - Comprehensive function documentation with proper parameter descriptions
    - Support for all required liquidity operations
    - Clean separation of concerns between different protocol interactions

### 3. Price Oracle Implementation [done]
**Objective:** Fetch on-chain Balancer pool prices with minimal off-chain dependencies
- **Requirements:**
  - **Use Balancer's on-chain vault/pools** to retrieve spot prices for collateral tokens (e.g., Balancer's `IVault`)
  - Avoid reliance on off-chain APIs; this is an MVP, so no fallback mechanism needed
  - Calculate resulting YES/NO token prices at half the collateral price (if relevant to your futarchy design)
- **Expected Output:** Reliable, on-chain price data for all relevant token pairs
- **Dependencies:** Contract interfaces from step 2
- **Implementation:**
  - **Files:**
    - `src/price-oracle/BalancerPriceOracle.sol` - Library for interacting with Balancer pools
    - `src/price-oracle/PriceOracleService.sol` - Service contract for price fetching and processing
    - `script/test_price_oracle.sh` - Test script for validating the price oracle
  - **Key Components:**
    - **Query Balancer Vault:**
      - Call `getPoolTokens(poolId)` to retrieve token balances
      - If using weighted pools, factor in token weights to compute the spot price
    - **Compute Spot Price:**
      - `spotPrice = (balanceIn / weightIn) / (balanceOut / weightOut)` (conceptual formula, depends on pool type)
    - **YES/NO Price Calculation:**
      - Use half of the collateral token's Balancer-based price as an initial reference for YES and NO tokens
  - **Data Structures:**
    - `TokenPriceData` - Struct for token price information
    - `ProposalPriceData` - Struct for complete proposal price data
  - **Commands:**
    - Test price oracle: `./script/test_price_oracle.sh`

### 4. Proposal Creation [done]
**Objective:** Deploy futarchy proposal through factory contract
- **Requirements:**
  - Construct CreateProposalParams from configuration
  - Execute transaction to FutarchyFactory.createProposal()
  - Handle transaction confirmation and receipt
  - Log proposal address and transaction details
- **Expected Output:** Deployed proposal contract address
- **Dependencies:** Configuration, interfaces, and signer from steps 1-2
- **Implementation:**
  - **Files:**
    - `script/FutarchyProposalLiquidity.s.sol` - Main script with proposal creation logic
    - `script/deploy_proposal_gnosis.sh` - Shell script wrapper for the Forge script
  - **Key Components:**
    - **createProposal Function:**
      - Constructs proposal parameters from configuration
      - Uses vm.startBroadcast with provided private key
      - Calls factory.createProposal with appropriate parameters
      - Handles errors with proper logging
    - **JSON Configuration Handling:**
      - Field-by-field parsing for robust error handling
      - String to numeric conversion for amount fields
      - Proper validation of all required parameters
  - **Deployment Commands:**
    - Single proposal: `./script/deploy_proposal_gnosis.sh script/config/proposal.json`
    - Batch proposals: `./script/deploy_proposal_gnosis.sh script/config/batch_proposals.json -- --sig "runBatch(string)"`

### 5. Conditional Token Extraction [done]
**Objective:** Extract and validate all conditional tokens from proposal
- **Requirements:**
  - Query FutarchyProposal for the four outcome tokens
  - Verify token existence and correct naming
  - Extract token metadata (symbol, decimals)
  - Map tokens to their respective roles (YES/NO and token types)
- **Expected Output:** Array of validated token addresses with metadata
- **Dependencies:** Proposal address from step 4
- **Implementation:**
  - **Files:**
    - `script/ExtractConditionalTokens.s.sol` - Main script for extracting and validating tokens
    - `script/extract_tokens.sh` - Shell wrapper for the Forge script
  - **Key Components:**
    - **Token Extraction Logic:**
      - Call `wrappedOutcome(uint256 index)` for all outcome indices
      - Extract and validate token addresses
      - Query token metadata (symbol, decimals)
      - Map tokens to appropriate types (YES/NO for each collateral)
    - **Output Format:**
      - JSON output containing token data
  - **Commands:**
    - Extract tokens: `./script/extract_tokens.sh <proposal_address>`
    - Save to file: `./script/extract_tokens.sh <proposal_address> --output tokens.json`
  - **Implementation Notes:**
    - Modified shell script to handle file output using redirection rather than Forge VM
    - Added proper error handling and validation for token metadata
    - Ensured compatibility with Gnosis Chain RPC endpoint
  - **Example Run:**
    - Command: `./script/extract_tokens.sh 0x6242AbA055957A63d682e9D3de3364ACB53D053A --output extracted_tokens.json`
    - Extracted 4 tokens from proposal:
      ```json
      {
        "proposalAddress": "0x6242AbA055957A63d682e9D3de3364ACB53D053A",
        "tokens": [
          {
            "index": 0,
            "address": "0x177304d505eCA60E1aE0dAF1bba4A4c4181dB8Ad",
            "type": "token1Yes",
            "symbol": "YES_GNO",
            "decimals": 18,
            "collateralToken": "0x9C58BAcC331c9aa871AFD802DB6379a98e80CEdb"
          },
          {
            "index": 1,
            "address": "0xf1B3E5Ffc0219A4F8C0ac69EC98C97709EdfB6c9",
            "type": "token1No",
            "symbol": "NO_GNO",
            "decimals": 18,
            "collateralToken": "0x9C58BAcC331c9aa871AFD802DB6379a98e80CEdb"
          },
          {
            "index": 2,
            "address": "0x493A0D1c776f8797297Aa8B34594fBd0A7F8968a",
            "type": "token2Yes",
            "symbol": "YES_sDAI",
            "decimals": 18,
            "collateralToken": "0xaf204776c7245bF4147c2612BF6e5972Ee483701"
          },
          {
            "index": 3,
            "address": "0xE1133Ef862f3441880adADC2096AB67c63f6E102",
            "type": "token2No",
            "symbol": "NO_sDAI",
            "decimals": 18,
            "collateralToken": "0xaf204776c7245bF4147c2612BF6e5972Ee483701"
          }
        ]
      }
      ```

### 6. Liquidity Calculation Engine [done]
**Objective:** Calculate optimal liquidity amounts and ratios for both v2 and v3 pools
- **Requirements:**
  - Use the **SushiSwap price oracle** to derive the token ratios for each pool
  - For v2 pools:
    - Calculate YES/WXDAI and NO/WXDAI pool liquidity based on the current collateral price (YES or NO ≈ half collateral price)
    - Create YES/YES and NO/NO pairs for additional liquidity options
  - For v3 pools:
    - Set concentrated liquidity around ±20% (a 1.2x range) of the spot price to handle volatility and attract volume
  - Scale final liquidity amounts according to a predefined USD budget or user config
- **Expected Output:** Complete liquidity parameters for all pools
- **Dependencies:** Price data from step 3, token addresses from step 5
- **Implementation:**
  - **Files:**
    - `src/liquidity/LiquidityCalculationEngine.sol` - Main contract for calculating optimal liquidity
    - `script/test_liquidity_calculation.sh` - Test script for validating the engine
  - **Key Components:**
    - **Data Structures:**
      - `TokenData` - Struct for token information (address, type, symbol, decimals, collateralToken)
      - `PoolLiquidity` - Struct for pool configuration (tokens, amounts, initialPrice, isV3, tickLower, tickUpper, fee)
      - `LiquidityConfig` - Struct for liquidity budget parameters (wxdaiAmount, token1Amount, token2Amount)
      - `TokenPrices` - Struct for token price information
    - **Main Functions:**
      - `calculateAllPoolLiquidity()` - Orchestrates the liquidity calculation for all pools
      - `calculateV2TokenWXDAIPools()` - Creates v2 pools for YES/WXDAI and NO/WXDAI pairs
      - `calculateV2YesNoPools()` - Creates v2 pools for YES/YES and NO/NO pairs
      - `calculateV3Pools()` - Creates v3 pools with concentrated liquidity
      - `calculateTickRange()` - Determines tick bounds for v3 pools based on price
      - `log2()` - Utility function to calculate logarithm base 2 for tick calculations
      - `roundToNearestSpacing()` - Ensures ticks align with pool spacing requirements
    - **Integration with Main Script:**
      - Added `extractConditionalTokens()` function in `FutarchyProposalLiquidity.s.sol` to extract tokens from proposals
      - Added `calculateLiquidity()` function to process token data and calculate liquidity parameters
      - Added functions to save calculated pool configurations to JSON
    - **Mathematical Formulas:**
      - v2 pools: token amounts calculated as `tokenAmount = (wxdaiAmount * 1e18) / tokenPrice`
      - v3 pools: price range set to ±20% (1.2x) around the spot price
      - v3 ticks: calculated using logarithmic approximation: `tick ≈ log(price) / log(1.0001)`
    - **Special Handling:**
      - Added validation to ensure v3 ticks are properly ordered (lower < upper)
      - Implemented fallback logic when tick calculation produces invalid ranges
      - Proper scaling of token amounts based on decimals and pricing
  - **Commands:**
    - Test liquidity calculation: `./script/test_liquidity_calculation.sh`
    - Run full integration: `source .env && forge script script/FutarchyProposalLiquidity.s.sol`
  - **Outputs:**
    - Creates 8 pools in total: 4 v2 token-WXDAI pools, 2 v2 YES/YES and NO/NO pools, and 2 v3 pools
    - Saves calculated pool configurations to `pool_liquidity.json`
    - Provides detailed logging of pool parameters for debugging

### 7. v2 Pool Deployment
**Objective:** Create all required SushiSwap v2 pools
- **Requirements:**
  - Deploy pools for each conditional token paired with WXDAI
  - Deploy v2 pools for token1yes/token2yes and token1no/token2no
  - Approve token spending for router contract
  - Add calculated initial liquidity to each pool
  - Verify pool creation and initial pricing
- **Expected Output:** Deployed v2 pool addresses with initial liquidity
- **Dependencies:** Token addresses from step 5, liquidity calculations from step 6

### 8. v3 Pool Parameter Calculation
**Objective:** Convert price ratios into ticks, fee tiers, and initial pool parameters for v3
- **Requirements:**
  1. **Determine Tick Range**:
     - Use ±20% price band (e.g., 1.2x) around the Balancer spot price
     - Convert these bounds to Uniswap v3 ticks with `TickMath.getTickAtSqrtRatio()`
  2. **Fee Tier**:
     - Use 0.1% for attracting high trading volume and handling volatility
  3. **Compute `sqrtPriceX96`**:
     - For reference, `sqrtPriceX96 = \(\sqrt{\frac{\text{token1Price}}{\text{token0Price}}}\) * 2^{96}`
     - Example (pseudo-code):
       ```js
       const priceRatio = priceToken1 / priceToken0;
       const sqrtPrice = Math.sqrt(priceRatio);
       const sqrtPriceX96 = sqrtPrice * (2 ** 96);
       ```
  4. **Optimal Token Amounts**:
     - Based on your total liquidity budget and desired price range, calculate how many tokens are required for initial concentrated liquidity
- **Expected Output:** Complete v3 pool initialization parameters
- **Dependencies:** Price data from step 3, liquidity calculations from step 6, token addresses from step 5

### 9. v3 Pool Deployment
**Objective:** Create SushiSwap v3 pools with concentrated liquidity
- **Requirements:**
  - Deploy v3 pools for token1yes/token2yes and token1no/token2no only
  - Use 0.1% fee tier
  - Configure ±20% price range around current market price
  - Add calculated concentrated liquidity
  - Verify pool initialization and price range
- **Expected Output:** Deployed v3 pool addresses with concentrated liquidity
- **Dependencies:** v3 parameters from step 8

### 10. Validation and Reporting
**Objective:** Verify all deployments and generate comprehensive report
- **Requirements:**
  - Validate all pool creations and liquidity additions
  - Check initial prices match expectations
  - Generate summary report with all addresses and parameters
  - Save results to output file for reference
  - Implement cleanup for any partial failures
- **Expected Output:** Validation results and complete deployment report
- **Dependencies:** All previous steps