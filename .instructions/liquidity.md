# Futarchy Proposal & Liquidity Pool Implementation Plan

## High-Level Objectives
- Create a futarchy proposal using existing factory on Gnosis Chain
- Extract conditional tokens generated by the proposal
- Create SushiSwap v2 pools for conditional tokens paired with WXDAI
- Create SushiSwap v2 pools for YES/NO token pairs
- Deploy SushiSwap v3 pools with concentrated liquidity for specific token pairs
- Ensure all pools are initialized with market-appropriate prices

## Tasks
- [x] 1. Configuration System Setup
- [x] 2. Contract Interface Integration
- [x] 3. Price Oracle Implementation
- [x] 4. Proposal Creation
- [x] 5. Conditional Token Extraction
- [ ] 6. Liquidity Calculation Engine
- [ ] 7. v2 Pool Deployment
- [ ] 8. v3 Pool Parameter Calculation
- [ ] 9. v3 Pool Deployment
- [ ] 10. Validation and Reporting

## Detailed Implementation Steps

### 1. Configuration System Setup [done]
**Objective:** Build a robust configuration parser for proposal settings and secrets
- **Requirements:**
  - Parse JSON proposal configuration (question, tokens, liquidity settings)
  - Load environment variables (private keys, contract addresses, RPC URLs)
  - Validate configuration completeness and format
  - Support array of proposals for batch processing
- **Expected Output:** Fully populated configuration object ready for use
- **Dependencies:** None
- **Implementation:**
  - **Files:**
    - `script/FutarchyProposalLiquidity.s.sol` - Main script with configuration parsing logic
    - `script/config/proposal.json` - Example single proposal configuration
    - `script/config/batch_proposals.json` - Example batch proposal configuration
    - `script/config/.env.example` - Template for environment variables
    - `script/config/README.md` - Documentation for configuration files
    - `script/test_config_parser.sh` - Test script for configuration parser
  - **Data Structures:**
    - `ProposalConfig` - Struct for proposal parameters (name, question, tokens, etc.)
    - `LiquidityConfig` - Struct for liquidity parameters (token amounts)
    - `EnvConfig` - Struct for environment variables (contract addresses, keys)
  - **Functions:**
    - `loadProposalConfig()` - Parses single proposal JSON configuration
    - `loadBatchProposalConfigs()` - Parses array of proposal configurations
    - `loadEnvConfig()` - Loads environment variables
    - `validateProposalConfig()` - Validates proposal configuration
    - `validateEnvConfig()` - Validates environment configuration
  - **Commands:**
    - Single proposal: `forge script script/FutarchyProposalLiquidity.s.sol:FutarchyProposalLiquidity --sig "run(string)" "script/config/proposal.json" --rpc-url $RPC_URL --private-key $PRIVATE_KEY`
    - Batch proposals: `forge script script/FutarchyProposalLiquidity.s.sol:FutarchyProposalLiquidity --sig "runBatch(string)" "script/config/batch_proposals.json" --rpc-url $RPC_URL --private-key $PRIVATE_KEY`
    - Test config parser: `./script/test_config_parser.sh`

### 2. Contract Interface Integration [done]
**Objective:** Establish communication with all required smart contracts
- **Requirements:**
  - Define interfaces for FutarchyFactory, FutarchyProposal, and FutarchyRouter
  - Create interfaces for SushiSwap v2 (Factory, Router, Pair)
  - Create interfaces for SushiSwap v3 (Factory, PositionManager, Pool)
  - Implement connection logic with proper ABI handling
- **Expected Output:** Functional contract interface instances
- **Dependencies:** Configuration from step 1
- **Implementation:**
  - **Files:**
    - `src/interfaces/IFutarchyFactory.sol` - Interface for creating futarchy proposals
    - `src/interfaces/IFutarchyProposal.sol` - Interface for interacting with proposals
    - `src/interfaces/IFutarchyRouter.sol` - Interface for managing proposal operations
    - `src/interfaces/ISushiswapV2Factory.sol` - Interface for creating SushiSwap v2 pairs
    - `src/interfaces/ISushiswapV2Pair.sol` - Interface for interacting with v2 pools
    - `src/interfaces/ISushiswapV2Router.sol` - Interface for adding liquidity to v2 pools
    - `src/interfaces/ISushiswapV3Factory.sol` - Interface for creating v3 pools
    - `src/interfaces/ISushiswapV3Pool.sol` - Interface for interacting with v3 pools
    - `src/interfaces/ISushiswapV3PositionManager.sol` - Interface for managing v3 positions
  - **Key Functionalities:**
    - **Futarchy Interfaces:**
      - Proposal creation and management
      - Conditional token extraction
      - Outcome token mapping (YES/NO tokens)
    - **SushiSwap v2 Interfaces:**
      - Pair creation and initialization
      - Liquidity provision
      - Reserve querying
    - **SushiSwap v3 Interfaces:**
      - Concentrated liquidity pool creation
      - Position management
      - Price range configuration
  - **Implementation Details:**
    - All interfaces aligned with Solidity 0.8.20 compiler version
    - Comprehensive function documentation with proper parameter descriptions
    - Support for all required liquidity operations
    - Clean separation of concerns between different protocol interactions

### 3. Price Oracle Implementation [done]
**Objective:** Create system to fetch and process current market prices
- **Requirements:**
  - Query SushiSwap API for current spot prices of collateral tokens vs WXDAI
  - Calculate token1/token2 price ratio
  - Handle API response errors with clear messaging
  - Calculate appropriate prices for YES/NO tokens (half of collateral price)
- **Expected Output:** Current price data for all relevant token pairs
- **Dependencies:** Contract interfaces from step 2
- **Implementation:**
  - **Files:**
    - `src/price-oracle/SushiswapPriceOracle.sol` - Library for interacting with SushiSwap API
    - `src/price-oracle/PriceOracleService.sol` - Service contract for price fetching and processing
    - `script/test_price_oracle.sh` - Test script for validating the price oracle
  - **Key Components:**
    - **SushiswapPriceOracle Library:**
      - HTTP API integration using VM FFI capabilities
      - Custom decimal string parsing
      - Price fetching and conversion to standard format (18 decimals)
    - **PriceOracleService Contract:**
      - Fetching price data for proposal tokens
      - Computing YES/NO token prices
      - Formatting and logging price information
  - **Data Structures:**
    - `TokenPriceData` - Struct for token price information
    - `ProposalPriceData` - Struct for complete proposal price data
  - **Commands:**
    - Test price oracle: `./script/test_price_oracle.sh`

### 4. Proposal Creation [done]
**Objective:** Deploy futarchy proposal through factory contract
- **Requirements:**
  - Construct CreateProposalParams from configuration
  - Execute transaction to FutarchyFactory.createProposal()
  - Handle transaction confirmation and receipt
  - Log proposal address and transaction details
- **Expected Output:** Deployed proposal contract address
- **Dependencies:** Configuration, interfaces, and signer from steps 1-2
- **Implementation:**
  - **Files:**
    - `script/FutarchyProposalLiquidity.s.sol` - Main script with proposal creation logic
    - `script/deploy_proposal_gnosis.sh` - Shell script wrapper for the Forge script
  - **Key Components:**
    - **createProposal Function:**
      - Constructs proposal parameters from configuration
      - Uses vm.startBroadcast with provided private key
      - Calls factory.createProposal with appropriate parameters
      - Handles errors with proper logging
    - **JSON Configuration Handling:**
      - Field-by-field parsing for robust error handling
      - String to numeric conversion for amount fields
      - Proper validation of all required parameters
  - **Deployment Commands:**
    - Single proposal: `./script/deploy_proposal_gnosis.sh script/config/proposal.json`
    - Batch proposals: `./script/deploy_proposal_gnosis.sh script/config/batch_proposals.json -- --sig "runBatch(string)"`

### 5. Conditional Token Extraction [done]
**Objective:** Extract and validate all conditional tokens from proposal
- **Requirements:**
  - Query FutarchyProposal for the four outcome tokens
  - Verify token existence and correct naming
  - Extract token metadata (symbol, decimals)
  - Map tokens to their respective roles (YES/NO and token types)
- **Expected Output:** Array of validated token addresses with metadata
- **Dependencies:** Proposal address from step 4
- **Implementation:**
  - **Files:**
    - `script/ExtractConditionalTokens.s.sol` - Main script for extracting and validating tokens
    - `script/extract_tokens.sh` - Shell wrapper for the Forge script
  - **Key Components:**
    - **Token Extraction Logic:**
      - Call `wrappedOutcome(uint256 index)` for all outcome indices
      - Extract and validate token addresses
      - Query token metadata (symbol, decimals)
      - Map tokens to appropriate types (YES/NO for each collateral)
    - **Output Format:**
      - JSON output containing token data
  - **Commands:**
    - Extract tokens: `./script/extract_tokens.sh <proposal_address>`
    - Save to file: `./script/extract_tokens.sh <proposal_address> --output tokens.json`
  - **Implementation Notes:**
    - Modified shell script to handle file output using redirection rather than Forge VM
    - Added proper error handling and validation for token metadata
    - Ensured compatibility with Gnosis Chain RPC endpoint
  - **Example Run:**
    - Command: `./script/extract_tokens.sh 0x6242AbA055957A63d682e9D3de3364ACB53D053A --output extracted_tokens.json`
    - Extracted 4 tokens from proposal:
      ```json
      {
        "proposalAddress": "0x6242AbA055957A63d682e9D3de3364ACB53D053A",
        "tokens": [
          {
            "index": 0,
            "address": "0x177304d505eCA60E1aE0dAF1bba4A4c4181dB8Ad",
            "type": "token1Yes",
            "symbol": "YES_GNO",
            "decimals": 18,
            "collateralToken": "0x9C58BAcC331c9aa871AFD802DB6379a98e80CEdb"
          },
          {
            "index": 1,
            "address": "0xf1B3E5Ffc0219A4F8C0ac69EC98C97709EdfB6c9",
            "type": "token1No",
            "symbol": "NO_GNO",
            "decimals": 18,
            "collateralToken": "0x9C58BAcC331c9aa871AFD802DB6379a98e80CEdb"
          },
          {
            "index": 2,
            "address": "0x493A0D1c776f8797297Aa8B34594fBd0A7F8968a",
            "type": "token2Yes",
            "symbol": "YES_sDAI",
            "decimals": 18,
            "collateralToken": "0xaf204776c7245bF4147c2612BF6e5972Ee483701"
          },
          {
            "index": 3,
            "address": "0xE1133Ef862f3441880adADC2096AB67c63f6E102",
            "type": "token2No",
            "symbol": "NO_sDAI",
            "decimals": 18,
            "collateralToken": "0xaf204776c7245bF4147c2612BF6e5972Ee483701"
          }
        ]
      }
      ```

### 6. Liquidity Calculation Engine
**Objective:** Calculate optimal liquidity amounts based on current prices
- **Requirements:**
  - Use price data to determine token ratios for each pool
  - Calculate v2 pool liquidity for YES/WXDAI and NO/WXDAI (at half collateral price)
  - Calculate v2 pool liquidity for YES/YES and NO/NO pairs
  - Determine v3 concentrated liquidity ranges (1.2x around current price)
  - Scale liquidity amounts based on configuration
- **Expected Output:** Complete liquidity parameters for all pools
- **Dependencies:** Price data from step 3, token addresses from step 5

### 7. v2 Pool Deployment
**Objective:** Create all required SushiSwap v2 pools
- **Requirements:**
  - Deploy pools for each conditional token paired with WXDAI
  - Deploy v2 pools for token1yes/token2yes and token1no/token2no
  - Approve token spending for router contract
  - Add calculated initial liquidity to each pool
  - Verify pool creation and initial pricing
- **Expected Output:** Deployed v2 pool addresses with initial liquidity
- **Dependencies:** Token addresses from step 5, liquidity calculations from step 6

### 8. v3 Pool Parameter Calculation
**Objective:** Calculate technical parameters for v3 concentrated liquidity
- **Requirements:**
  - Convert price ratios to tick ranges for v3 pools
  - Calculate lower and upper ticks for 1.2x range around current price
  - Determine optimal token amounts for concentrated liquidity
  - Define fee tier settings (0.1%)
- **Expected Output:** Complete v3 pool initialization parameters
- **Dependencies:** Price data from step 3, token pairs from step 5

### 9. v3 Pool Deployment
**Objective:** Create SushiSwap v3 pools with concentrated liquidity
- **Requirements:**
  - Deploy v3 pools for token1yes/token2yes and token1no/token2no only
  - Use 0.1% fee tier
  - Configure 1.2x price range around current market price
  - Add calculated concentrated liquidity
  - Verify pool initialization and price range
- **Expected Output:** Deployed v3 pool addresses with concentrated liquidity
- **Dependencies:** v3 parameters from step 8

### 10. Validation and Reporting
**Objective:** Verify all deployments and generate comprehensive report
- **Requirements:**
  - Validate all pool creations and liquidity additions
  - Check initial prices match expectations
  - Generate summary report with all addresses and parameters
  - Save results to output file for reference
  - Implement cleanup for any partial failures
- **Expected Output:** Validation results and complete deployment report
- **Dependencies:** All previous steps